/*
 * Copyright (c) 2008 Poesys Associates. All rights reserved.
 * 
 * This file is part of Poesys-DB.
 * 
 * Poesys-DB is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * Poesys-DB is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Poesys-DB. If not, see <http://www.gnu.org/licenses/>.
 */
package com.poesys.db.dao.insert;


import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;

import com.poesys.db.DbErrorException;
import com.poesys.db.InvalidParametersException;
import com.poesys.db.Message;
import com.poesys.db.NoPrimaryKeyException;
import com.poesys.db.dao.AbstractBatch;
import com.poesys.db.dao.PoesysTrackingThread;
import com.poesys.db.dto.IDbDto;
import com.poesys.db.pk.IPrimaryKey;
import com.poesys.db.pk.IdentityPrimaryKey;


/**
 * <p>
 * An implementation of the IInsertBatch generic interface that contains the
 * base code for inserting a batch of objects into the database. To use this
 * class, you must implement the IInsertSql interface for the concrete class
 * that contains the SQL INSERT statement and the JDBC code to set the
 * parameters in the JDBC result set, then pass that object into the InsertBatch
 * constructor. The insert() method will insert all objects in the input
 * collection that have the status NEW, then change status to EXISTING.
 * </p>
 * <p>
 * <em>Note: You cannot insert batches of objects with identity (auto-generated)
 * keys because the underlying JDBC standard does not support getting back the
 * key values. Use InsertCollection instead. InsertNoKey inserts a single
 * identity-key object.</em>
 * </p>
 * 
 * @see com.poesys.db.dto.ISet
 * @see com.poesys.db.dto.IDbDto
 * @see com.poesys.db.dto.AbstractDto
 * @see com.poesys.db.dao.insert.InsertCollection
 * @see com.poesys.db.dao.insert.InsertNoKey
 * 
 * @author Robert J. Muller
 * @param <T> the database DTO type to insert
 */
public class InsertBatch<T extends IDbDto> extends AbstractBatch<T> implements
    IInsertBatch<T> {
  /** Logger for debugging */
  private static final Logger logger = Logger.getLogger(InsertBatch.class);
  /** The helper class for generating the SQL statement */
  private final IInsertSql<T> sql;

  /** message string for exceptions */
  private static final String BATCH_MSG = "com.poesys.db.dao.msg.batch_of_dtos";
  /** Error message when no primary key supplied */
  private static final String NO_KEY_ERROR =
    "com.poesys.db.dao.insert.msg.no_primary_key_for_insert";
  /** Error message when identity primary key supplied */
  private static final String IDENTITY_KEY_ERROR =
    "com.poesys.db.dao.insert.msg.no_batch_autogenerated_keys";
  /** Error message when thread is interrupted or timed out */
  private static final String THREAD_ERROR = "com.poesys.db.dao.msg.thread";
  /** Error message when insert throws exception */
  private static final String INSERT_ERROR =
    "com.poesys.db.dao.insert.msg.insert";

  /** timeout for the cache thread */
  private static final int TIMEOUT = 1000 * 60;

  /**
   * Create an Insert object by supplying the concrete implementation of the
   * SQL-statement generator and JDBC setter.
   * 
   * @param sql the SQL INSERT statement generator object
   * @param subsystem the subsystem of class T
   */
  public InsertBatch(IInsertSql<T> sql, String subsystem) {
    super(subsystem);
    this.sql = sql;
  }

  @Override
  public void insert(Collection<T> dtos, int size) {
    // If the current thread is a PoesysTrackingThread, just batch insert in
    // that thread; if not, start a new thread for the inserts.
    if (Thread.currentThread() instanceof PoesysTrackingThread) {
      PoesysTrackingThread thread =
        (PoesysTrackingThread)Thread.currentThread();
      insertBatch(thread.getConnection(), dtos, size);
    } else {
      Runnable process = new Runnable() {
        public void run() {
          PoesysTrackingThread thread =
            (PoesysTrackingThread)Thread.currentThread();
          try {
            insertBatch(thread.getConnection(), dtos, size);
            // Post process here as the client is not in the tracking thread.
            postProcessNestedObjects(dtos);
          } catch (Throwable e) {
            thread.setThrowable(e);
          } finally {
            thread.closeConnection();
          }
        }

        /**
         * Post-process a collection of DTOs.
         * 
         * @param dtos the DTOs
         */
        private void postProcessNestedObjects(Collection<T> dtos) {
          if (dtos != null) {
            for (T dto : dtos) {
              // Post process DTO, as client isn't in tracking thread.
              dto.postprocessNestedObjects();
            }
          }
        }
      };
      PoesysTrackingThread thread =
        new PoesysTrackingThread(process, subsystem);
      thread.start();

      // Join the thread, blocking until the thread completes or
      // until the query times out.
      try {
        thread.join(TIMEOUT);
        // Check for problems.
        if (thread.getThrowable() != null) {
          Object[] args = { "insert", Message.getMessage(BATCH_MSG, null) };
          String message = Message.getMessage(THREAD_ERROR, args);
          logger.error(message, thread.getThrowable());
          throw new DbErrorException(message, thread.getThrowable());
        }
      } catch (InterruptedException e) {
        Object[] args = { "insert", Message.getMessage(BATCH_MSG, null) };
        String message = Message.getMessage(THREAD_ERROR, args);
        logger.error(message, e);
      }
    }
  }

  /**
   * Insert the contents of a collection of DTO objects into the database in
   * batches of a specified size. Only DTOs with the isNew() flag set to true
   * that have not yet been processed get inserted. This method is run within a
   * container PoesysTrackingThread.
   * 
   * @param connection the SQL connection to use to do the inserts
   * @param dtos the DTOs to insert
   * @param size the size of the batches to process
   */
  @SuppressWarnings("unchecked")
  private void insertBatch(Connection connection, Collection<T> dtos, int size) {
    PreparedStatement stmt = null;
    String dtoType = null; // string for error messages
    int[] codes = null; // array of return codes from JDBC batch processing
    // Current DTOs for error processing
    List<T> list = new ArrayList<T>();
    int count = 0; // counter for number of objects processed in batch
    PoesysTrackingThread thread = (PoesysTrackingThread)Thread.currentThread();

    // Iterate only if there are DTOs to iterate over.
    if (dtos != null) {
      try {
        for (T dto : dtos) {
          // Check that the primary key is there.
          IPrimaryKey key = dto.getPrimaryKey();
          if (key == null) {
            // Something's very wrong, so abort the whole insert.
            throw new NoPrimaryKeyException(Message.getMessage(NO_KEY_ERROR,
                                                               null));
          } else if (key instanceof IdentityPrimaryKey) {
            // Can't process an identity key using this class.
            throw new InvalidParametersException(Message.getMessage(IDENTITY_KEY_ERROR,
                                                                    null));
          } else if (thread.getDto(key) == null
                     && dto.getStatus() == IDbDto.Status.NEW) {
            dtoType = dtoType == null ? key.getStringKey() : dtoType;
            /*
             * The DTO is NEW and has not already been processed (as it is is
             * not registered in the tracking thread). Run any validation after
             * querying nested objects to be able to use them in validation.
             */
            dto.queryNestedObjectsForValidation();
            dto.validateForInsert();
            /*
             * Preprocess any nested objects to insert them, if required. This
             * sets the key to which the foreign key in the current object will
             * refer. This applies only to to-one, non-child objects that do not
             * contain the primary key of the current object; to-many and child
             * objects get inserted after the main insert loop (see below).
             */
            dto.preprocessNestedObjects();

            // Check again for the DTO in the thread as it may already have
            // been inserted through the nested object preprocessing step.
            if (thread.getDto(key) == null) {
              count++;

              /*
               * The first time through the loop, build the batched SQL
               * statement and prepare it. The statement will track the batch
               * and send it to the database when the size is reached.
               */
              if (stmt == null) {
                stmt = connection.prepareStatement(sql.getSql(key).toString());
              }
              logger.debug("Adding insert to batch with key " + key
                           + " in thread " + thread.getName());
              logger.debug("SQL: " + sql.getSql(key));
              logger.debug("Parameters: " + sql.getParamString(dto));
              // Set the key value into the parameters as the first set of
              // parameters, then set the rest of the parameters.
              int next = key.setInsertParams(stmt, 1);
              sql.setParams(stmt, next, dto);
              stmt.addBatch();
              // Add the DTO to the current batch list for error processing.
              list.add(dto);
              // Add the DTO to the tracking thread if not already tracked.
              if (thread.getDto(key) == null) {
                thread.addDto(dto);
              }
              if (count == size) {
                try {
                  stmt.executeBatch();
                  // Reset the batch variables for the next batch.
                  count = 0;
                  list.clear();
                } catch (BatchUpdateException e) {
                  logger.error("Batch insert exception", e);
                  codes = e.getUpdateCounts();
                  // Reset the batch variables for the next batch.
                  count = 0;
                  list.clear();
                  thread.processErrors(codes, (Collection<IDbDto>)list);
                }
              }
            }
          }
        }
      } catch (SQLException e) {
        Object[] args =
          { Message.getMessage(BATCH_MSG, null) + ": batch example " + dtoType };
        String message = Message.getMessage(INSERT_ERROR, args);
        logger.error(message, e);
        throw new DbErrorException(message, thread, e);
      } finally {
        // Execute the last batch, if any.
        if (count > 0 && stmt != null) {
          try {
            codes = stmt.executeBatch();
          } catch (BatchUpdateException e) {
            codes = e.getUpdateCounts();
            thread.processErrors(codes, (Collection<IDbDto>)list);
            Object[] args =
              { Message.getMessage(BATCH_MSG, null) + ": batch example "
                + dtoType };
            String message = Message.getMessage(INSERT_ERROR, args);
            throw new DbErrorException(message, thread, e);
          } catch (SQLException e) {
            Object[] args =
              { Message.getMessage(BATCH_MSG, null) + ": batch example "
                + dtoType };
            String message = Message.getMessage(INSERT_ERROR, args);
            throw new DbErrorException(message, thread, e);
          }
        }
        // Close the statement as required.
        if (stmt != null) {
          try {
            stmt.close();
          } catch (SQLException e) {
            // ignore
          }
        }
      }

      /*
       * For a concrete class, insert any to-many or child nested objects for
       * successfully inserted DTOs. In batch processing, you must first insert
       * ALL the parent DTOs so that the keys exist for the foreign keys in the
       * child DTOs, hence the child inserts must be in a completely separate
       * loop after the first loop that inserts the parents. Only process NEW
       * DTOs here, don't process EXISTING, FAILED, CHANGED, or DELETED DTOs.
       * Note that it doesn't matter if the main DTO was processed, as all the
       * nested DTOs will have an appropriate status or processed flag.
       */
      for (IDbDto dto : dtos) {
        if (dto.getStatus() == IDbDto.Status.NEW && !dto.isAbstractClass()) {
          dto.insertNestedObjects();
        }
      }
    }
  }

  @Override
  public void close() {
    // Nothing to do
  }
}
