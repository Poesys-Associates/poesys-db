/*
 * Copyright (c) 2008 Poesys Associates. All rights reserved.
 * 
 * This file is part of Poesys-DB.
 * 
 * Poesys-DB is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * Poesys-DB is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Poesys-DB. If not, see <http://www.gnu.org/licenses/>.
 */
package com.poesys.db.dao.insert;


import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;

import com.poesys.db.BatchException;
import com.poesys.db.InvalidParametersException;
import com.poesys.db.NoPrimaryKeyException;
import com.poesys.db.dao.AbstractBatch;
import com.poesys.db.dto.IDbDto;
import com.poesys.db.pk.IPrimaryKey;
import com.poesys.db.pk.IdentityPrimaryKey;


/**
 * <p>
 * An implementation of the IInsertBatch generic interface that contains the
 * base code for inserting a batch of objects into the database. To use this
 * class, you must implement the IInsertSql interface for the concrete class
 * that contains the SQL INSERT statement and the JDBC code to set the
 * parameters in the JDBC result set, then pass that object into the InsertBatch
 * constructor. The insert() method will insert all objects in the input
 * collection that have the status NEW.
 * </p>
 * <p>
 * <em>Note: You cannot insert batches of objects with identity (auto-generated)
 * keys because the underlying JDBC standard does not support getting back the
 * key values. Use InsertCollection instead. InsertNoKey inserts a single
 * identity-key object.</em>
 * </p>
 * 
 * @see com.poesys.db.dto.ISet
 * @see com.poesys.db.dto.IDbDto
 * @see com.poesys.db.dto.AbstractDto
 * @see com.poesys.db.dao.insert.InsertCollection
 * @see com.poesys.db.dao.insert.InsertNoKey
 * 
 * @author Robert J. Muller
 * @param <T> the database DTO type to insert
 */
public class InsertBatch<T extends IDbDto> extends AbstractBatch<T> implements
    IInsertBatch<T> {
  /** Logger for debugging */
  private static final Logger logger = Logger.getLogger(InsertBatch.class);
  /** The helper class for generating the SQL statement */
  private final IInsertSql<T> sql;
  /** Error message when no primary key supplied */
  private static final String NO_KEY_MSG =
    "com.poesys.db.dao.insert.msg.no_primary_key_for_insert";
  /** Error message when identity primary key supplied */
  private static final String IDENTITY_KEY_MSG =
    "com.poesys.db.dao.insert.msg.no_batch_autogenerated_keys";
  /**
   * Shared string builder for error string
   */
  private StringBuilder builder = new StringBuilder();
  /**
   * Flag for whether batch has errors
   */
  private boolean hasErrors = false;

  /**
   * Create an Insert object by supplying the concrete implementation of the
   * SQL-statement generator and JDBC setter.
   * 
   * @param sql the SQL INSERT statement generator object
   */
  public InsertBatch(IInsertSql<T> sql) {
    this.sql = sql;
  }

  @Override
  public void insert(Connection connection, Collection<T> dtos, int size)
      throws SQLException, BatchException {
    PreparedStatement stmt = null;
    int[] codes = null; // array of return codes from JDBC batch processing
    // Current DTOs for error processing
    List<T> list = new ArrayList<T>();
    int count = 0; // counter for number of objects processed in batch
    IPrimaryKey key = null;

    // Iterate only if there are DTOs to iterate over.
    if (dtos != null) {
      try {
        for (T dto : dtos) {
          // Check that the primary key is there.
          IPrimaryKey newkey = dto.getPrimaryKey();
          if (newkey == null) {
            // Something's very wrong, so abort the whole insert.
            throw new NoPrimaryKeyException(NO_KEY_MSG);
          } else if (newkey instanceof IdentityPrimaryKey) {
            // Can't process an identity key using this class.
            throw new InvalidParametersException(IDENTITY_KEY_MSG);
          } else if (!dto.isProcessed() && dto.getStatus() == IDbDto.Status.NEW) {
            /*
             * The DTO is NEW. Run any validation after querying nested objects
             * to be able to use them in validation.
             */
            dto.queryNestedObjectsForValidation();
            dto.validateForInsert();
            /*
             * Preprocess any nested objects to insert them, if required. This
             * sets the key to which the foreign key in the current object will
             * refer. This applies only to to-one, non-child objects that do not
             * contain the primary key of the current object; to-many and child
             * objects get inserted after the main insert loop (see below).
             */
            dto.preprocessNestedObjects(connection);

            count++;

            // Get the primary key.
            key = dto.getPrimaryKey();
            /*
             * The first time through the loop, build the batched SQL statement
             * and prepare it. The statement will track the batch and send it to
             * the database when the size is reached.
             */
            if (stmt == null) {
              stmt = connection.prepareStatement(sql.getSql(key).toString());
            }
            // Set the key value into the parameters as the first set of
            // parameters, then set the rest of the parameters.
            int next = key.setInsertParams(stmt, 1);
            sql.setParams(stmt, next, dto);
            stmt.addBatch();
            logger.debug("Adding insert to batch with key " + key);
            logger.debug("SQL: " + sql.getSql(key));
            // Add the DTO to the current batch list for error processing.
            list.add(dto);
            if (count == size) {
              try {
                stmt.executeBatch();
                // Reset the batch variables for the next batch.
                count = 0;
                list.clear();
              } catch (BatchUpdateException e) {
                codes = e.getUpdateCounts();
                // Reset the batch variables for the next batch.
                count = 0;
                list.clear();
                builder.append(e.getMessage() + ": ");
                hasErrors = processErrors(codes, list, builder);
              }
            }
          }
        }
      } finally {
        // Execute the last batch, if any.
        if (count > 0 && stmt != null) {
          try {
            codes = stmt.executeBatch();
            setProcessed(list, true);
          } catch (BatchUpdateException e) {
            codes = e.getUpdateCounts();
            builder.append(e.getMessage() + ": ");
            setProcessed(list, true);
            hasErrors = processErrors(codes, list, builder);
          }
        }
        // Close the statement as required.
        if (stmt != null) {
          stmt.close();
        }
      }

      /*
       * For a concrete class, insert any to-many or child nested objects for
       * successfully inserted DTOs. In batch processing, you must first insert
       * ALL the parent DTOs so that the keys exist for the foreign keys in the
       * child DTOs, hence the child inserts must be in a completely separate
       * loop after the first loop that inserts the parents. Only process NEW
       * DTOs here, don't process EXISTING, FAILED, CHANGED, or DELETED DTOs.
       * Note that it doesn't matter if the main DTO was processed, as all the
       * nested DTOs will have an appropriate status or processed flag.
       */
      for (IDbDto dto : dtos) {
        if (dto.getStatus() == IDbDto.Status.NEW && !dto.isAbstractClass()) {
          dto.insertNestedObjects(connection);
        }
      }

      // If there are errors, print the SQL and throw a batch exception.
      if (hasErrors) {
        if (key != null) {
          logger.error(builder.toString());
          logger.error(sql.getSql(key));
        }
        throw new BatchException(builder.toString());
      }
    }
  }

  @Override
  public void close() {
    // Nothing to do
  }
}
