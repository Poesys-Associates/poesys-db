/*
 * Copyright (c) 2008 Poesys Associates. All rights reserved.
 * 
 * This file is part of Poesys-DB.
 * 
 * Poesys-DB is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * Poesys-DB is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * Poesys-DB. If not, see <http://www.gnu.org/licenses/>.
 */
package com.poesys.db.dao.insert;


import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;

import com.poesys.db.BatchException;
import com.poesys.db.InvalidParametersException;
import com.poesys.db.Message;
import com.poesys.db.NoPrimaryKeyException;
import com.poesys.db.dao.AbstractBatch;
import com.poesys.db.dao.PoesysTrackingThread;
import com.poesys.db.dto.IDbDto;
import com.poesys.db.pk.IPrimaryKey;
import com.poesys.db.pk.IdentityPrimaryKey;


/**
 * <p>
 * An implementation of the IInsertBatch generic interface that contains the
 * base code for inserting a batch of objects into the database. To use this
 * class, you must implement the IInsertSql interface for the concrete class
 * that contains the SQL INSERT statement and the JDBC code to set the
 * parameters in the JDBC result set, then pass that object into the InsertBatch
 * constructor. The insert() method will insert all objects in the input
 * collection that have the status NEW.
 * </p>
 * <p>
 * <em>Note: You cannot insert batches of objects with identity (auto-generated)
 * keys because the underlying JDBC standard does not support getting back the
 * key values. Use InsertCollection instead. InsertNoKey inserts a single
 * identity-key object.</em>
 * </p>
 * 
 * @see com.poesys.db.dto.ISet
 * @see com.poesys.db.dto.IDbDto
 * @see com.poesys.db.dto.AbstractDto
 * @see com.poesys.db.dao.insert.InsertCollection
 * @see com.poesys.db.dao.insert.InsertNoKey
 * 
 * @author Robert J. Muller
 * @param <T> the database DTO type to insert
 */
public class InsertBatch<T extends IDbDto> extends AbstractBatch<T> implements
    IInsertBatch<T> {
  /** Logger for debugging */
  private static final Logger logger = Logger.getLogger(InsertBatch.class);
  /** The helper class for generating the SQL statement */
  private final IInsertSql<T> sql;

  /** Warning message when insert contains DTOs with the same key */
  private static final String DUPLICATE_INSERT_WARNING =
    "Duplicate insert ignored: ";
  /** Error message when no primary key supplied */
  private static final String NO_KEY_MSG =
    "com.poesys.db.dao.insert.msg.no_primary_key_for_insert";
  /** Error message when identity primary key supplied */
  private static final String IDENTITY_KEY_MSG =
    "com.poesys.db.dao.insert.msg.no_batch_autogenerated_keys";
  /** Error message when thread is interrupted or timed out */
  private static final String THREAD_ERROR = "com.poesys.db.dao.msg.thread";
  /** Error message when insert throws exception */
  private static final String INSERT_ERROR =
    "com.poesys.db.dao.insert.msg.insert";

  /** Shared string builder for error string */
  private StringBuilder builder = new StringBuilder();
  /** Flag for whether batch has errors */
  private boolean hasErrors = false;

  /** timeout for the cache thread */
  private static final int TIMEOUT = 1000 * 60;

  /**
   * Create an Insert object by supplying the concrete implementation of the
   * SQL-statement generator and JDBC setter.
   * 
   * @param sql the SQL INSERT statement generator object
   */
  public InsertBatch(IInsertSql<T> sql) {
    this.sql = sql;
  }

  @Override
  public void insert(Connection connection, Collection<T> dtos, int size)
      throws SQLException, BatchException {
    // If the current thread is a PoesysTrackingThread, just batch insert in
    // that
    // thread; if not, start a new thread for the inserts.
    if (Thread.currentThread() instanceof PoesysTrackingThread) {
      insertBatch(connection, dtos, size);
    } else {
      Runnable process = new Runnable() {
        public void run() {
          try {
            insertBatch(connection, dtos, size);
          } catch (SQLException e) {
            Object[] args = { "batch of DTOs" };
            String message = Message.getMessage(INSERT_ERROR, args);
            logger.error(message, e);
            throw new RuntimeException(message, e);
          } catch (BatchException e) {
            Object[] args = { "batch of DTOs" };
            String message = Message.getMessage(INSERT_ERROR, args);
            logger.error(message, e);
            throw new RuntimeException(message, e);
          }
        }
      };
      PoesysTrackingThread thread = new PoesysTrackingThread(process);
      thread.start();

      // Join the thread, blocking until the thread completes or
      // until the query times out.
      try {
        thread.join(TIMEOUT);
      } catch (InterruptedException e) {
        Object[] args = { "insert", "batch of DTOs" };
        String message = Message.getMessage(THREAD_ERROR, args);
        logger.error(message, e);
      }
    }
  }

  /**
   * Insert the contents of a collection of DTO objects into the database in
   * batches of a specified size. Only DTOs with the isNew() flag set to true
   * that have not yet been processed get inserted. This method is run within a
   * container PoesysTrackingThread.
   * 
   * @param connection the SQL connection to use to do the inserts
   * @param dtos the DTOs to insert
   * @param size the size of the batches to process
   * @throws SQLException when there is a database problem
   * @throws BatchException when there is a batch processing problem
   */
  private void insertBatch(Connection connection, Collection<T> dtos, int size)
      throws SQLException, BatchException {
    PreparedStatement stmt = null;
    int[] codes = null; // array of return codes from JDBC batch processing
    // Current DTOs for error processing
    List<T> list = new ArrayList<T>();
    int count = 0; // counter for number of objects processed in batch
    PoesysTrackingThread thread = (PoesysTrackingThread)Thread.currentThread();

    // Iterate only if there are DTOs to iterate over.
    if (dtos != null) {
      try {
        for (T dto : dtos) {
          // Check that the primary key is there.
          IPrimaryKey key = dto.getPrimaryKey();
          // Check whether the object is in the thread history.
          if (key == null) {
            // Something's very wrong, so abort the whole insert.
            throw new NoPrimaryKeyException(NO_KEY_MSG);
          } else if (key instanceof IdentityPrimaryKey) {
            // Can't process an identity key using this class.
            throw new InvalidParametersException(IDENTITY_KEY_MSG);
          } else if (dto.getStatus() == IDbDto.Status.NEW) {
            if (thread.getDto(key.getStringKey()) == null) {
              // Not in history, add it to be able to set it processed
              thread.addDto(dto);
            } else if (thread.isProcessed(key.getStringKey())) {
              // insert already processed, warn about duplicate
              logger.warn(DUPLICATE_INSERT_WARNING + key.getStringKey());
              continue;
            }
            /*
             * The DTO is NEW. Run any validation after querying nested objects
             * to be able to use them in validation.
             */
            dto.queryNestedObjectsForValidation();
            dto.validateForInsert();
            /*
             * Preprocess any nested objects to insert them, if required. This
             * sets the key to which the foreign key in the current object will
             * refer. This applies only to to-one, non-child objects that do not
             * contain the primary key of the current object; to-many and child
             * objects get inserted after the main insert loop (see below).
             */
            dto.preprocessNestedObjects(connection);

            count++;

            // Get the primary key.
            key = dto.getPrimaryKey();
            /*
             * The first time through the loop, build the batched SQL statement
             * and prepare it. The statement will track the batch and send it to
             * the database when the size is reached.
             */
            if (stmt == null) {
              stmt = connection.prepareStatement(sql.getSql(key).toString());
            }
            // Set the key value into the parameters as the first set of
            // parameters, then set the rest of the parameters.
            int next = key.setInsertParams(stmt, 1);
            sql.setParams(stmt, next, dto);
            stmt.addBatch();
            logger.debug("Adding insert to batch with key " + key);
            String sqlStr = sql.getSql(key);
            logger.debug("SQL: " + sqlStr);
            // Add the DTO to the current batch list for error processing.
            list.add(dto);
            // Set the DTO to have processed status.
            thread.setProcessed(key.getStringKey(), true);
            if (count == size) {
              try {
                stmt.executeBatch();
                // Reset the batch variables for the next batch.
                count = 0;
                list.clear();
              } catch (BatchUpdateException e) {
                codes = e.getUpdateCounts();
                // Reset the batch variables for the next batch.
                count = 0;
                list.clear();
                builder.append(e.getMessage());
                builder.append(": ");
                builder.append(sqlStr);
                hasErrors = processErrors(codes, list, builder);
              }
            }
          }
        }
      } finally {
        // Execute the last batch, if any.
        if (count > 0 && stmt != null) {
          try {
            codes = stmt.executeBatch();
          } catch (BatchUpdateException e) {
            codes = e.getUpdateCounts();
            builder.append(e.getMessage() + ": ");
            hasErrors = processErrors(codes, list, builder);
          }
        }
        // Close the statement as required.
        if (stmt != null) {
          stmt.close();
        }
      }

      /*
       * For a concrete class, insert any to-many or child nested objects for
       * successfully inserted DTOs. In batch processing, you must first insert
       * ALL the parent DTOs so that the keys exist for the foreign keys in the
       * child DTOs, hence the child inserts must be in a completely separate
       * loop after the first loop that inserts the parents. Only process NEW
       * DTOs here, don't process EXISTING, FAILED, CHANGED, or DELETED DTOs.
       * Note that it doesn't matter if the main DTO was processed, as all the
       * nested DTOs will have an appropriate status or processed flag.
       */
      for (IDbDto dto : dtos) {
        if (dto.getStatus() == IDbDto.Status.NEW && !dto.isAbstractClass()) {
          dto.insertNestedObjects(connection);
        }
      }

      // If there are errors, print the SQL and throw a batch exception.
      if (hasErrors) {
        logger.error(builder.toString());
        throw new BatchException(builder.toString());
      }
    }
  }

  @Override
  public void close() {
    // Nothing to do
  }
}
